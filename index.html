<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CS 4621: Final Project -- Music Visualizer</title>

  <!-- Bootstrap -->
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/cs4620.css" rel="stylesheet">
  <link href="css/jquery-ui.min.css" rel="stylesheet">
  <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
  <link href="css/jquery-ui.structure.min.css" rel="stylesheet">

  <script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous">
  </script>

  <script language="javascript" type="text/javascript" src="js/p5.js"></script>
  <script language="javascript" type="text/javascript" src="js/p5.sound.js"></script>
  <script language="javascript" type="text/javascript" src="js/gl-matrix-min.js"></script>
  <script language="javascript" type="text/javascript" src="js/preloadjs-0.6.2.min.js"></script>
  <script language="javascript" type="text/javascript" src="js/boilerplate.js"></script>

  <style>
    body { background-color: white; color: black; }
    button {
      color: black;
      background-color: white;
      display: block;
      margin-top: 10px;
      padding-left: 18px; padding-right: 18px;
      border: none;
    }

    .song-select{
      float: right;
    }

    #play-bar {
      display: black;
      margin-left: auto; margin-right: auto;
      margin-bottom: 25px;
      width: 50%;
    }

    select{
      margin: 10px;
    }

    canvas{margin-top: 50px;}


  </style>
</head>

<body>

  <!-- <label for="js-song">Choose Song:</label>
  <input type="file" id="js-song"> -->

  <!-- <div id="play-bar">
    <button id="play">Play</button>
    <input type="range" id="slide" value="0" />
  </div> -->

  <div>
    <select name="" id="js-songs" class="song-select">
      <option value="https://soundcloud.com/itndylan/lemons-dylan">Lemons</option>
      <option value="https://soundcloud.com/lidogotsongs/feel-it-still-lido-remix">Feel it Still</option>
      <option value="https://soundcloud.com/liluzivert/15-xo-tour-llif3">XO TOUR Lif3</option>
      <option value="https://soundcloud.com/green-mountain-boys/power-moves-rough">Power Moves [Rough]</option>
      <option value="https://soundcloud.com/travisscott-2/11-grey">Grey - Travis Scott</option>
    </select>
  </div>

  <div align="center">
    <canvas tabindex="1" id="webglCanvas" style="border: none; background-color: black;" width="1000" height="800"></canvas>
  </div>

  <script src="js/bundle.js" charset="utf-8"></script>

  <script id="vertexShader--basic" type="x-shader/x-vertex">
    attribute vec3 position;

    uniform mat4 projection;
    uniform mat4 toWorld;
    uniform mat4 toCam;
    uniform vec3 color;

    void main() {
      gl_Position = projection * toCam * toWorld * vec4(position, 1.0);
    }
  </script>

  <script id="fragmentShader--basic" type="x-shader/x-fragment">
    precision highp float;
    uniform vec3 color;

    void main() {
      gl_FragColor = vec4(color, 1.0);
    }
  </script>

  <script>

  var analyzer;

  function getSongFromURL() {
    var hash = window.location.hash;
    return hash.substring(1);
  }

  $('#js-songs').on('change', function(){
    if(window.location.hash != ""){
      var cur = window.location.href;
      var id = cur.indexOf('#');
      var cur = cur.substring(0,id);
    } else {
      var cur = window.location.href;
    }
    var url = this.value;
    var newURL = cur+"#"+url;
    console.log(newURL);
    window.location.href = newURL;
    location.reload();
  })

  // Scene Objects  ---------------------------------------------------

  // create particle object centered at [x], [y], [z] with scale [s]
  function createParticle(x, y, z, s, c) {
    var particle = {};

    // Instantiate particle
    particle.position = [x, y, z];
    particle.scale = [s, s, s];
    particle.baseColor = vec3.fromValues(c[0], c[1], c[2]);
    particle.color = vec3.fromValues(c[0], c[1], c[2]);

    // Create [particle.toWorld] matrix
    updateToWorldMatrix(particle);

    return particle;
  }

  /*
   * create 2D sheet of particles with properties:
   * - [numX]
   * - [numZ]
   * - [minX]
   * - [maxX]
   * - [minZ]
   * - [maxZ]
   */
  function createParticleSheet(numX, numZ, minX, maxX, minZ, maxZ) {
    var width = maxX - minX;
    var height = maxZ - minZ;

    var particles = {};
    particles.list = [];
    particles.position = [0, 0, 0];
    particles.scale = [1, 1, 1];

    for (var i = 0; i < numX; i++) {
      particles.list[i] = [];
      for (var j = 0; j < numZ; j++) {
        // Create particle
        var x = ((i / (numX-1)) * width) + minX;
        var z = ((j / (numZ-1)) * height) + minZ;
        var color = [Math.abs(x), Math.abs(z), Math.abs((x + z) / 2)];
        particles.list[i][j] = createParticle(x, 0, z, 0.01, color);
      }
    }

    // Create [particles.toWorld]
    updateToWorldMatrix(particles);

    return particles;
  }

  /**
   * Offset the particle to [value]
   * [particle] is offset along the y axis
   */
  function moveParticle(particle, value) {
    particle.position[1] = value;
    var colorScale = vec3.fromValues(Math.random(), Math.random(), Math.random());
    vec3.scale(colorScale, colorScale, 6 * value);
    particle.color = vec3.add(particle.color, particle.baseColor, colorScale);

    updateToWorldMatrix(particle);
  }

  /**
   * create the scene for our visualization
   * the [scene] object has the following fields:
   * - [camera]
   * - [particles]
   * - [shape]: shape for each particle
   */
  function createScene(camera, particles, shape) {
    var scene = {
      camera: camera,
      particles: particles,
      shape: shape
    };

    return scene;
  }

  /**
   * draw all the objects in the scene
   * [scene] has the following properties:
   * - [particles]
   *   - [list]
   *   - [toWorld]
   * - [camera]
   *   - [toWorld]
   *   - [projection]
   */
  function drawScene(gl, scene) {
    // Draw each particle
    for (var i = 0; i < particles.list.length; i++) {
      for (var j = 0; j < particles.list[i].length; j++) {
        var particle = particles.list[i][j];
        var toWorld = mat4.create();
        mat4.mul(toWorld, particles.toWorld, particle.toWorld);
        drawShape(gl, scene.shape, camera, toWorld, particle.color);
      }
    }
  }

  /**
   * update scene according to music data
   * [spectrum] - amplitudes across frequency spectrum
   *              range: [0, 255]
   * [waveform] - snapshot of amplitude readings
   *              range: [-1.0, +1.0]
   * [scale] - scale factor for particle offset
   */
  function updateScene(scene, spectrum, waveform, scale, threshold) {
    // Scale [waveform] by [spectrum]
    for (var i = 0; i < scene.particles.list.length; i++) {
      for (var j = 0; j < scene.particles.list[i].length; j++) {
        var particle = scene.particles.list[i][j];
        var spectrumAmp = spectrum[i]/50;
        var waveformAmp = waveform[j]/50;

        var v = (spectrumAmp / 255) * waveformAmp * scale;
        //console.log("spectrumAmp: " + spectrumAmp);
        //console.log("waveformAmp: " + waveformAmp);
        //console.log("v: " + v + "\n");
        if (v > threshold) {
          moveParticle(particle, v);
        } else {
          moveParticle(particle, 0);
        }
      }
    }
  }

  /**
   * update [object.toWorld] matrix according to the [object] properties:
   * - [position]: array [x, y, z]
   * - [scale]: array [sx, sy, sz] or null
   */
  function updateToWorldMatrix(object) {
    // Create Translation matrix
    var [x, y, z] = object.position;
    var translation = vec3.fromValues(x,y,z);
    var T = mat4.create();
    mat4.fromTranslation(T, translation);

    // Create Scale Matrix
    var S = mat4.create();
    if (object.scale != null) {
      var [sx, sy, sz] = object.scale;
      var scale = vec3.fromValues(sx,sy,sz);
      mat4.fromScaling(S, scale);
    }

    // Update [object.toWorld] matrix
    object.toWorld = mat4.create();
    mat4.mul(object.toWorld, T, S);

    return object;
  }

  /**
   * update [scene] to move camera around by [offset]
   */
  function updateSceneOffset(scene, offset) {
    var [x, y, z] = offset;
    var v = Math.PI/500;

    // Check if flipped
    var vec = vec3.fromValues(0, 1, 0);
    var vecTrans = vec3.create();
    vec3.transformMat4(vecTrans, vec, scene.particles.toWorld);
    var angle = vec3.angle(vec, vecTrans);
    if (angle > Math.PI/2) {
      y = -y;
    }

    var Rx = mat4.create();
    mat4.fromXRotation(Rx, x*v);
    mat4.mul(scene.particles.toWorld, Rx, scene.particles.toWorld);

    var Ry = mat4.create();
    mat4.fromYRotation(Ry, y*v);
    mat4.mul(scene.particles.toWorld, scene.particles.toWorld, Ry);

    var Tz = mat4.create();
    var offsetZ = vec3.fromValues(0, 0, z/50);
    vec3.add(scene.camera.position, scene.camera.position, offsetZ);
    if (scene.camera.position[2] < 0) {
      scene.camera.position[2] = 0;
    } else if (scene.camera.position[2] > 100) {
      scene.camera.position[2] = 100;
    }
    updateToWorldMatrix(scene.camera);
  }

  // WebGL --------------------------------------------------------------------
  // Global Vars
  var gl = initializeWebGL($("#webglCanvas"));
  var basic_shader = createGlslProgram(gl, "vertexShader--basic", "fragmentShader--basic");
  var fft = null;
  var sound = null;
  var smoothing = 0.99;   // range: (0.0, 1.0), def: 0.8
  var bins = 64;   // range: [16, 1024], def: 1024 - MUST be power of 2
  var scaleFactor = 4;  // scale factor (amplitude) for visulization
  var threshold = 0.01;  // threshold visualization value must be above to move
  var offset = [50,-190,0];   // offset for controlling camera movement

  // Create Projection Matrix (Perspective Camera)
  var perspectiveMatrix = mat4.create();
  var fovy = (45.0 / 180.0) * Math.PI;
  var aspect = $("#webglCanvas").attr("width") / $("#webglCanvas").attr("height");
  var near = 0.1;
  var far = 100.0;
  mat4.perspective(perspectiveMatrix, fovy, aspect, near, far);

  // Create Camera
  var camera = {};
  //camera.radius = 3.0;
  //camera.theta = 0.0;
  //camera.phi = 0.0;
  camera.origin = [0.0, 0.0, 0.0];
  camera.projection = perspectiveMatrix;
  camera.position = vec3.fromValues(0, 0, 3);
  camera.radius = vec3.length(camera.position);
  camera.scale = [1,1,1];
  updateToWorldMatrix(camera);

  // Create particles
  var particles = createParticleSheet(bins, bins, -1, 1, -1, 1);

  // Create shape
  var cube = createShape(gl, basic_shader, cubeData, true);

  // Create scene
  var scene = createScene(camera, particles, cube);

  // UpdateWebGL --------------------------------------------------------------
  var prevTime = 0;
  function updateWebGL(time) {
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (sound != null && sound.isPlaying()) {
      $('#slide').val(sound.currentTime());
    }
    // Update Scene based on song data (time in ms)
    if (time - prevTime > 9) {
      if (fft != null && sound != null && sound.isPlaying()) {
        // Song is playing
        var spectrum = fft.analyze();
        var waveform = fft.waveform();
        updateScene(scene, spectrum, waveform, scaleFactor, threshold);

        //var s = Math.abs(fft.waveform()[0]) * 10;
        //scene.particles.scale = [s, s, s];
        //updateToWorldMatrix(scene.particles);
      }
    }

    if(analyzer){
      var waves = analyzer.waveform();
      var spec = waves.map(function(m) {
        var val = m/255; return val; });
      console.log(waves);
      updateScene(scene, waves, waves, scaleFactor,threshold);
    }


    // Update Camera Position if it has been offset
    updateSceneOffset(scene, offset);
    offset = [0, 0, 0];

    // Draw Scene
    drawScene(gl, scene);

    // Reschedule the next frame.
    prevTime = time;
    window.requestAnimationFrame(updateWebGL);
  }
  window.requestAnimationFrame(updateWebGL);



  // Events -------------------------------------------------------------------
  var dragging = false;   // whether or not user is dragging the camera
  var mousePos;   // [screenX, screenY]
  var mouseTime;  // time of last mouse event

  /**
   * Move rotate camera with click events
   */
  $("#webglCanvas").on('mousedown', function(event) {
    mousePos = [event.clientX, event.clientY];
    mouseTime = event.time;
    dragging = true;
  });

  $("#webglCanvas").on('mouseup mouseleave', function(event) {
    dragging = false;
  });

  $("#webglCanvas").on('mousemove', function(event) {
    if (dragging) {
      var [prevX, prevY] = mousePos;

      var dx = event.clientX - prevX;
      var dy = event.clientY - prevY;

      offset[1] += dx;
      offset[0] += dy;

      mousePos = [event.clientX, event.clientY];
    }
  });


  $("#webglCanvas").on("wheel", function(event) {
    event.preventDefault();
    offset[2] += event.originalEvent.deltaY;
  });


  var map = {
    87: false,
    83: false,
    65: false,
    68: false,
    81: false,
    69: false
  };
  /**
   * Move rotate camera from WASD, SHIFT, SPACEBAR
   * - W/S: rotate up/down
   * - A/D: rotate left/right
   * - Q/E: zoom in/out
   */
  $("#webglCanvas").on('keydown', function(event) {

    // Update map
    if (event.keyCode in map) {
      map[event.keyCode] = true;
    }

    var s = 3;
    
    // W - rotate up - incr x
    if (map[87]) {
       offset[0] += s;
    }

    // S - rotate down - decr x
    if (map[83]) {
       offset[0] -= s;
    }

    // A - rotate left - incr y
    if (map[65]) {
       offset[1] += s;
    }

    // D - rotate right - incr y
    if (map[68]) {
       offset[1] -= s;
    }

    // Q - zoom out - incr z
    if (map[81]) {
       offset[2] += s/2;
    }

    // E - zoom in - decr z
    if (map[69]) {
       offset[2] -= s/2;
    }
  });

  $("#webglCanvas").on('keyup', function(event) {
    // Update map
    if (event.keyCode in map) {
      map[event.keyCode] = false;
    }
  });


  // NOT SURE WE WANT TO GO ON CHANGE, PROBABLY ON BUTTON PRESS, BUT TESTING FOR NOW

  //$('#js-song').on('change', function() {
//
      //var url = $(this).val();
      //var song = url.split('\\').pop();
      //console.log(song);
//
      //var s = function(p) {
//
        //p.preload = function() {
          //p.soundFormats('m4a');
          //sound = p.loadSound('assets/'+song);
        //}
//
        //p.setup = function() {
          //fft = new p5.FFT();
          //fft.smoothing = smoothing;
          //fft.bins = bins;
          //sound.amp(0.2);
          //sound.pause();
          //$('#slide').attr('max', sound.duration());
          //$('#slide').on('input', function() {
            //var pause = sound.isPaused();
            //sound.jump($(this).val());
            //if (pause) { sound.pause(); }
          //});
        //}
//
        //p.draw = function() {
          //var spectrum = fft.analyze();
          //var waveform = fft.waveform();
        //}
//
        //p.togglePlay = function() {
          //if ( sound.isPlaying() ) {
            //sound.pause();
            //$('#play').html('Play');
          //} else {
            //sound.play();
            //$('#play').html('Pause');
          //}
        //}
//
        //$('#play').on('click', p.togglePlay);
//
      //}
//
      //var myp5 = new p5(s);
//
  //});

  </script>
</body>

</html>
