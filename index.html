<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CS 4621: Final Project -- Music Visualizer</title>

  <!-- Bootstrap -->
  <link href="css/bootstrap.min.css" rel="stylesheet">

  <script language="javascript" type="text/javascript" src="js/jquery-3.1.1.min.js"></script>
  <script language="javascript" type="text/javascript" src="js/gl-matrix-min.js"></script>
  <script language="javascript" type="text/javascript" src="js/boilerplate.js"></script>


  <style>
    body { background-color: white; color: black; font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; }
    button {
      color: black;
      background-color: white;
      display: block;
      margin-top: 10px;
      padding-left: 18px; padding-right: 18px;
      border: none;
    }

    .song-select{
      float: right;
    }

    #play-bar {
      display: black;
      margin-left: auto; margin-right: auto;
      margin-bottom: 25px;
      width: 50%;
    }

    select{
      margin: 10px;
      color: black;
      background-color: white;
      font-weight: 500;
    }

    canvas{margin: 100px auto;}

    .flex{
      width: 100%;
      height: 110vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .song-btns{
      float: right;
      margin: 10px;
      font-weight: 700;
    }

  </style>
</head>

<body>

  <div>
    <select name="" id="js-songs" class="song-select">
      <option value="https://soundcloud.com/verzache/conscious">Conscious</option>
      <option value="https://soundcloud.com/itndylan/lemons-dylan">Lemons</option>
      <option value="https://soundcloud.com/lidogotsongs/feel-it-still-lido-remix">Feel it Still</option>
      <option value="https://soundcloud.com/liluzivert/15-xo-tour-llif3">XO TOUR Lif3</option>
      <option value="https://soundcloud.com/green-mountain-boys/power-moves-rough">Power Moves [Rough]</option>
      <option value="https://soundcloud.com/travisscott-2/11-grey">Grey - Travis Scott</option>
      <option value="https://soundcloud.com/santandave/wanna-know-remix-feat-drake">Wanna Know - Dave</option>
    </select>
  </div>

  <div class="song-btns">
    <p class="js-pause">Pause</p>
  </div>

  <div class="flex">
    <canvas tabindex="1" id="webglCanvas" style="border: none; background-color: black;" width="1000" height="600"></canvas>
  </div>

  <script src="js/bundle.js" charset="utf-8"></script>
  <script src="js/perlin.js" charset="utf-8"></script>

  <script id="vertexShader--basic" type="x-shader/x-vertex">
    attribute vec3 position;

    uniform mat4 projection;
    uniform mat4 toWorld;
    uniform mat4 toCam;
    uniform vec3 color;

    void main() {
      gl_Position = projection * toCam * toWorld * vec4(position, 1.0);
    }
  </script>

  <script id="fragmentShader--basic" type="x-shader/x-fragment">
    precision highp float;
    uniform vec3 color;
    uniform float displacement;

    vec4 aqua = vec4(0.0, 207.0, 202.0, 255.0) / 255.0;
    vec4 white = vec4(1.0);
    vec4 purp = vec4(59.0, 38.0, 130.0, 255.0) / 255.0;

    void main() {
      gl_FragColor = purp;
      //if (displacement == 1.0) {
        //if (color.x > color.y && color.x > color.z) {
          //gl_FragColor = aqua;
        //} else if (color.y > color.x && color.y > color.z) {
          //gl_FragColor = white;
        //} else {
          //gl_FragColor = purp;
        //}
      //} else {
        //gl_FragColor = purp;
      //}


    }
  </script>

  <script id="vertexShader--background1" type="x-shader/x-vertex">
    attribute vec3 vert_position;
    attribute vec2 vert_texCoord;

    varying vec2 texCoord;

    void main() {
      gl_Position = vec4(vert_position, 1.0);
      texCoord = vert_texCoord;
    }
  </script>

  <script id="fragmentShader--background1" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 texCoord;

    void main() {
      gl_FragColor = ((3.0 - texCoord.x) / 4.5 * vec4(1.0)) + vec4(1.0, 0.27, 0.73, 1.0);
    }
  </script>

  <script id="vertexShader--background2" type="x-shader/x-vertex">
    attribute vec3 vert_position;
    attribute vec2 vert_texCoord;

    varying vec2 texCoord;

    void main() {
      gl_Position = vec4(vert_position, 1.0);
      texCoord = vert_texCoord;
    }
  </script>

  <script id="fragmentShader--background2" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 texCoord;

    void main() {
      gl_FragColor = ((3.0 - texCoord.x) / 4.5 * vec4(1.0)) + vec4(1.0, 0.27, 0.73, 1.0);
    }
  </script>

  <script>
  var canPlay = false;
  var analyser;
  var waveArray;
  var freqArray;
  var bufferLength;

  function getSongFromURL() {
    var hash = window.location.hash;
    return hash.substring(1);
  }

  $('#js-songs').on('change', function(){
    if(window.location.hash != ""){
      var cur = window.location.href;
      var id = cur.indexOf('#');
      var cur = cur.substring(0,id);
    } else {
      var cur = window.location.href;
    }
    var url = this.value;
    var newURL = cur+"#"+url;
    window.location.href = newURL;
    location.reload();
  })

  // Scene Objects  ---------------------------------------------------

  // create particle object centered at [x], [y], [z] with scale [s]
  function createParticle(x, y, z, s, c) {
    var particle = {};

    // Instantiate particle
    particle.position = [x, y, z];
    particle.scale = [s, s, s];
    particle.baseColor = vec3.fromValues(c[0], c[1], c[2]);
    particle.color = vec3.fromValues(c[0], c[1], c[2]);
    particle.displacement = 0.0;

    // Create [particle.toWorld] matrix
    updateToWorldMatrix(particle);

    return particle;
  }

  /*
   * create 2D sheet of particles with properties:
   * - [numX]
   * - [numZ]
   * - [minX]
   * - [maxX]
   * - [minZ]
   * - [maxZ]
   */
  function createParticleSheet(numX, numZ, minX, maxX, minZ, maxZ) {
    var width = maxX - minX;
    var height = maxZ - minZ;

    var particles = {};
    particles.list = [];
    particles.position = [0, 0, 0];
    particles.scale = [1, 1, 1];

    for (var i = 0; i < numX; i++) {
      particles.list[i] = [];
      for (var j = 0; j < numZ; j++) {
        // Create particle
        var x = ((i / (numX-1)) * width) + minX;
        var z = ((j / (numZ-1)) * height) + minZ;
        var color = [Math.abs(x), Math.abs(z), Math.abs((x + z) / 2)];
        particles.list[i][j] = createParticle(x, 0, z, 0.01, color);
      }
    }

    // Create [particles.toWorld]
    updateToWorldMatrix(particles);

    return particles;
  }

  /**
   * Offset the particle to [value]
   * [particle] is offset along the y axis
   */
  function moveParticle(particle, value, dir) {
    particle.position[1] = dir * value;
    var colorScale = vec3.fromValues(Math.random(), Math.random(), Math.random());
    vec3.scale(colorScale, colorScale, 6 * value);
    particle.color = vec3.add(particle.color, particle.baseColor, colorScale);

    updateToWorldMatrix(particle);
  }

  /**
   * create the scene for our visualization
   * the [scene] object has the following fields:
   * - [camera]
   * - [particles]
   * - [shape]: shape for each particle
   */
  function createScene(camera, particles, shape) {
    var scene = {
      camera: camera,
      particles: particles,
      shape: shape
    };

    return scene;
  }

  /**
   * draw all the objects in the scene
   * [scene] has the following properties:
   * - [particles]
   *   - [list]
   *   - [toWorld]
   * - [camera]
   *   - [toWorld]
   *   - [projection]
   */
  function drawScene(gl, scene) {
    // Draw each particle
    for (var i = 0; i < particles.list.length; i++) {
      for (var j = 0; j < particles.list[i].length; j++) {
        var particle = particles.list[i][j];
        var toWorld = mat4.create();
        mat4.mul(toWorld, particles.toWorld, particle.toWorld);
        drawShape(gl, scene.shape, camera, toWorld, particle.color, particle.displacement);
      }
    }
  }

  /**
   * update scene according to music data
   * [spectrum] - amplitudes across frequency spectrum
   *              range: [0, 255]
   * [waveform] - snapshot of amplitude readings
   *              range: [-1.0, +1.0]
   * [scale] - scale factor for particle offset
   */
  var inc = 0;
  function updateScene(scene, spectrum, waveform, scale, threshold) {
    // Scale [waveform] by [spectrum]
    var displaced = 0;
    for (var i = 0; i < scene.particles.list.length; i++) {
      for (var j = 0; j < scene.particles.list[i].length; j++) {
        var particle = scene.particles.list[i][j];
        var spectrumAmp = spectrum[i]/100;
        var waveformAmp = waveform[j]/100;

        var vNoise = 0.5 * PerlinNoise.noise((i+inc)/30,(j+inc)/30,.5);

        //var vSound = 5 * (spectrumAmp / 255) * waveformAmp * scale;
        var vSound = (spectrumAmp / 255) * scale;
        //console.log("spectrumAmp: " + spectrumAmp);
        //console.log("waveformAmp: " + waveformAmp);
        //console.log("v: " + v + "\n");
        //console.log("threshold: " + threshold);

        //vNoise = PerlinNoise.noise((i+inc)/50,(j+inc)/50,.5);
        //vSound = (spectrumAmp / 255) * waveformAmp * scale;

        //var v = vNoise + 7 * vSound;
        var v = vNoise + 9 * (vSound - threshold);
        //console.log("vSound: " + vSound);

        if (vSound > threshold) {
          moveParticle(particle, v, 1.0);
          //if (Math.random() > 0.5) { moveParticle(particle, v, 1.0); }
          //else { moveParticle(particle, v, -0.3); }
          particle.displacement = 1.0;
          displaced++;
        } else {
          moveParticle(particle, vNoise, 1.0);
          particle.displacement = 0.0;
        }
      }
    }
    if (displaced >= scene.particles.list.length * scene.particles.list[0].length / 2) { setWire(); }
    else { setCube(); }
  }

  /**
   * update [object.toWorld] matrix according to the [object] properties:
   * - [position]: array [x, y, z]
   * - [scale]: array [sx, sy, sz] or null
   */
  function updateToWorldMatrix(object) {
    // Create Translation matrix
    var [x, y, z] = object.position;
    var translation = vec3.fromValues(x,y,z);
    var T = mat4.create();
    mat4.fromTranslation(T, translation);

    // Create Scale Matrix
    var S = mat4.create();
    if (object.scale != null) {
      var [sx, sy, sz] = object.scale;
      var scale = vec3.fromValues(sx,sy,sz);
      mat4.fromScaling(S, scale);
    }

    // Update [object.toWorld] matrix
    object.toWorld = mat4.create();
    mat4.mul(object.toWorld, T, S);

    return object;
  }

  /**
   * update [scene] to move camera around by [offset]
   */
  function updateSceneOffset(scene, offset) {
    var [x, y, z] = offset;
    var v = Math.PI/500;

    var Rx = mat4.create();
    mat4.fromXRotation(Rx, x*v);
    mat4.mul(scene.particles.toWorld, Rx, scene.particles.toWorld);

    // Keep rotation around x bound by 180 degrees
    var vec = vec3.fromValues(0, 1, 0);
    var vecTrans = vec3.create();
    vec3.transformMat4(vecTrans, vec, scene.particles.toWorld);
    var angle = vec3.angle(vec, vecTrans);
    if (angle > Math.PI/2) {
      var sign = 1;
      if (vecTrans[2] < 0) {
        sign = -1;
      }
      // Stop rotation around x
      var RxBack = mat4.create();
      mat4.fromXRotation(RxBack, sign * ((Math.PI/2) - angle) );
      mat4.mul(scene.particles.toWorld, RxBack, scene.particles.toWorld);
    }

    var Ry = mat4.create();
    mat4.fromYRotation(Ry, y*v);
    mat4.mul(scene.particles.toWorld, scene.particles.toWorld, Ry);

    var Tz = mat4.create();
    var offsetZ = vec3.fromValues(0, 0, z/50);
    vec3.add(scene.camera.position, scene.camera.position, offsetZ);

    // Check min/max zoom
    var min = 0.5;
    var max = 30;
    if (scene.camera.position[2] < min) {
      scene.camera.position[2] = min;
    } else if (scene.camera.position[2] > max) {
      scene.camera.position[2] = max;
    }
    updateToWorldMatrix(scene.camera);
  }

  // WebGL --------------------------------------------------------------------
  // Global Vars
  var gl = initializeWebGL($("#webglCanvas"));
  var basic_shader = createGlslProgram(gl, "vertexShader--basic", "fragmentShader--basic");
  var background_shader1 = createGlslProgram(gl, "vertexShader--background1", "fragmentShader--background1");
  var background_shader2 = createGlslProgram(gl, "vertexShader--background2", "fragmentShader--background2");
  //var fft = null;
  //var sound = null;
  var smoothing = 0.99;   // range: (0.0, 1.0), def: 0.8
  var bins = 64;   // range: [16, 1024], def: 1024 - MUST be power of 2
  var scaleFactor = 4;  // scale factor (amplitude) for visulization
  var threshold = 0.020;  // threshold visualization value must be above to move
  var offset = [50,-190,0];   // offset for controlling camera movement
  var analyser;

  // Create Projection Matrix (Perspective Camera)
  var perspectiveMatrix = mat4.create();
  var fovy = (45.0 / 180.0) * Math.PI;
  var aspect = $("#webglCanvas").attr("width") / $("#webglCanvas").attr("height");
  var near = 0.1;
  var far = 100.0;
  mat4.perspective(perspectiveMatrix, fovy, aspect, near, far);

  // Create Camera
  var camera = {};
  //camera.radius = 3.0;
  //camera.theta = 0.0;
  //camera.phi = 0.0;
  camera.origin = [0.0, 0.0, 0.0];
  camera.projection = perspectiveMatrix;
  camera.position = vec3.fromValues(0, 0, 3);
  //camera.radius = vec3.length(camera.position);
  camera.scale = [1,1,1];
  updateToWorldMatrix(camera);

  // Create particles
  var particles = createParticleSheet(bins, bins, -1, 1, -1, 1);

  // Create shape
  var cube = createShape(gl, basic_shader, cubeData, true);
  var wireframe = createShape(gl, basic_shader, cubeData, false);

  // Create scene
  var cubescene = createScene(camera, particles, cube);
  var wirescene = createScene(camera, particles, wireframe);

  cubescene.background_shader = background_shader1;
  wirescene.background_shader = background_shader2;

  var scenetype = 'cube';

  var setCube = function () { scenetype = 'cube'; };
  var setWire = function () { scenetype = 'wire'; };

  function getScene(type) {
    switch (type) {
      case 'cube':  return cubescene;
      case 'wire': return wirescene;
      default: return cubescene;
    }
  }

  // UpdateWebGL --------------------------------------------------------------
  var prevTime = 0;
  function updateWebGL(time) {

    scene = getScene(scenetype);
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.clear(gl.COLOR_BUFFER_BIT);


    if(canPlay && (time - prevTime) > 100) {
      prevTime = time;
      analyser.getByteTimeDomainData(waveArray); // Wavalength data
      analyser.getByteFrequencyData(freqArray);  // Frequency data
      if($('.js-pause').text() == 'Pause') inc += .5;
      updateScene(scene, waveArray, freqArray, scaleFactor,threshold);
    }

    drawBackground(scene.background_shader);


    // Update Camera Position if it has been offset
    updateSceneOffset(scene, offset);
    offset = [0, 0, 0];

    // Draw Scene
    drawScene(gl, scene);

    // Reschedule the next frame.
    //prevTime = time;
    window.requestAnimationFrame(updateWebGL);
  }
  window.requestAnimationFrame(updateWebGL);



  // Events -------------------------------------------------------------------
  var dragging = false;   // whether or not user is dragging the camera
  var mousePos;           // [screenX, screenY]
  var mouseTime;          // time of last mouse event

  /**
   * Move rotate camera with click events
   */
  $("#webglCanvas").on('mousedown', function(event) {
    mousePos = [event.clientX, event.clientY];
    mouseTime = event.time;
    dragging = true;
  });

  $("#webglCanvas").on('mouseup mouseleave', function(event) {
    dragging = false;
  });

  $("#webglCanvas").on('mousemove', function(event) {
    if (dragging) {
      var [prevX, prevY] = mousePos;

      var dx = event.clientX - prevX;
      var dy = event.clientY - prevY;

      offset[1] += dx;
      offset[0] += dy;

      mousePos = [event.clientX, event.clientY];
    }
  });


  $("#webglCanvas").on("wheel", function(event) {
    event.preventDefault();
    offset[2] += event.originalEvent.deltaY;
  });


  var map = {
    87: false,
    83: false,
    65: false,
    68: false,
    81: false,
    69: false
  };
  /**
   * Move rotate camera from WASD, SHIFT, SPACEBAR
   * - W/S: rotate up/down
   * - A/D: rotate left/right
   * - Q/E: zoom in/out
   */
  $("#webglCanvas").on('keydown', function(event) {

    // Update map
    if (event.keyCode in map) {
      map[event.keyCode] = true;
    }

    var s = 3;

    // W - rotate up - incr x
    if (map[87]) {
       offset[0] += s;
    }

    // S - rotate down - decr x
    if (map[83]) {
       offset[0] -= s;
    }

    // A - rotate left - incr y
    if (map[65]) {
       offset[1] += s;
    }

    // D - rotate right - incr y
    if (map[68]) {
       offset[1] -= s;
    }

    // Q - zoom out - incr z
    if (map[81]) {
       offset[2] += s/2;
    }

    // E - zoom in - decr z
    if (map[69]) {
       offset[2] -= s/2;
    }
  });

  $("#webglCanvas").on('keyup', function(event) {
    // Update map
    if (event.keyCode in map) {
      map[event.keyCode] = false;
    }
  });


  </script>
</body>

</html>
